# Feature Specification: Асинхронный обработчик объявлений Avito

**Feature Branch**: `001-async-avito-parser`  
**Created**: 20 октября 2025  
**Status**: Draft  
**Input**: User description: "ТЗ: Асинхронная система массовой обработки объявлений Avito" + уточнения о схеме `new`, файлах прокси и автосоздании таблиц

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Массовая обработка файла ID (Priority: P1)

Оператор загружает файл `data/items.txt`, запускает обработку и получает сохранённые в БД карточки объявлений без ручного вмешательства.

**Почему этот приоритет**: Это основная бизнес-ценность — превращение списков ID в структурированные данные для аналитики.

**Независимое тестирование**: Запустить обработку тестового файла на 100+ ID и проверить, что статусы объявлений записаны в `new.listings` без ручной доработки.

**Acceptance Scenarios**:

1. **Given** подготовленный файл с корректными ID и доступ к БД, **When** оператор запускает обработку, **Then** все записи получают статус `success` или `unavailable`, а карточки с данными присутствуют в таблице `new.listings`.
2. **Given** запись уже существует в `new.listings`, **When** объявление обрабатывается повторно, **Then** поле `processed_at` обновляется, а данные карточки актуализируются через UPSERT без дубликатов.

---

### User Story 2 - Автовосстановление при сбоях (Priority: P2)

Система автоматически повторяет попытки обработки задачи с учётом блокировок и капчи, не требуя участия оператора.

**Почему этот приоритет**: Автовосстановление снижает потери из-за блокировок и обеспечивает стабильность парсинга.

**Независимое тестирование**: Смоделировать последовательность 403 и 429 ответов и подтвердить, что задачи переочередяются, прокси переключаются по правилам, а итоговая обработка завершается.

**Acceptance Scenarios**:

1. **Given** прокси возвращает 403, **When** воркер фиксирует блокировку, **Then** прокси записывается в файл заблокированных, задача возвращается в очередь и успешно завершается на следующем прокси.
2. **Given** страница выдаёт Geetest капчу, **When** `resolve_captcha_flow` не справляется, **Then** воркер сменяет прокси (без блокировки предыдущего), повторяет попытку и доводит задачу до статуса `success` или `unavailable`.

---

### User Story 3 - Минимальная наблюдаемость процессов (Priority: P3)

Команда поддержки отслеживает ход обработки через короткие журнальные записи и базовые счетчики, чтобы видеть успешные задачи, повторы и заблокированные прокси.

**Почему этот приоритет**: Нужна видимость основных событий без перегрузки логами и метриками.

**Независимое тестирование**: Запустить обработку тестового набора ID и убедиться, что на задачу создаётся не более одного лог-сообщения на изменение состояния, а агрегированные счётчики показывают число задач по основным статусам.

**Acceptance Scenarios**:

1. **Given** система обрабатывает файл, **When** задача меняет состояние (успех, капча, блокировка, отсутствие объявления), **Then** в лог записывается одно компактное сообщение с ID и действием.
2. **Given** обработка завершена, **When** инженер просматривает минимальный набор метрик, **Then** он видит суммарное число успешных задач, блокировок и перезапусков без детализированных спанов.

---

### Edge Cases

- Что происходит, если в `items.txt` дублирующиеся или некорректные ID: дубликаты игнорируются после первой выдачи, некорректные ID логируются и пропускаются.
- Что происходит, если файл `/Users/stepanorlov/Desktop/STARTED/onezamer_v2/data/proxies.txt` отсутствует или пуст: очередь ставится на паузу, в лог пишется одно сообщение о необходимости пополнить файл.
- Как система реагирует, если все доступные прокси попали в список заблокированных: задачи остаются в очереди, воркеры переходят в режим ожидания до ручного восстановления списка.
- Как обрабатывается недоступность БД или схемы `new`: запускается экспоненциальный бэкофф, после восстановления соединения создаётся схема/таблица и обработка продолжается.
- Что происходит при форсированном завершении процесса: текущая задача возвращается в очередь, браузерные контексты закрываются, прокси освобождаются.

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: При запуске система загружает настройки из файла `.env` через модуль `config.py` (пути файлов, DSN PostgreSQL, параметры воркеров, лимиты попыток); CLI-параметры не применяются, значения централизуются в конфигурации.
- **FR-002**: Система считывает файл `data/items.txt`, валидирует формат ID и генерирует канонический URL объявления до постановки задачи в очередь в соответствии с конфигурацией.
- **FR-003**: Общая асинхронная очередь задач обязана выдавать каждый ID только одному воркеру одновременно, помечать активные задачи состоянием `in_progress` и при возврате задачи увеличивать счётчик попыток; максимальное число повторов (`MAX_ATTEMPTS`, по умолчанию 5) задаётся в `config.py`, после превышения задача помечается как `error`.
- **FR-004**: При запуске раннера необходимо установить соединение с PostgreSQL (host `81.30.105.134`, port `5402`, database `avito_zamer`, user `admin`, password `root`) и убедиться в наличии доступа к схеме `new`.
- **FR-005**: Если схема `new` или таблица `new.listings` и связанный триггер отсутствуют, система должна создать их по заданному DDL до старта обработки.
- **FR-006**: Глобальный пул соединений `asyncpg` создаётся в раннере, его размер задаётся параметром `DB_POOL_SIZE` из `config.py`, и он переиспользуется всеми воркерами.
- **FR-007**: При инициализации система загружает все активные прокси из файла `/Users/stepanorlov/Desktop/STARTED/onezamer_v2/data/proxies.txt`, формирует кольцевой пул с потокобезопасным доступом (lock), обновляет состояние прокси, исключая гонки при смене/блокировке, и переиспользует записи без дублирования.
- **FR-008**: Каждый воркер при старте получает следующий доступный прокси, создаёт браузер и страницу Playwright и переиспользует их до критической ошибки.
- **FR-009**: После каждого `page.goto` воркер обязан дождаться состояния `domcontentloaded`, затем вызвать `detect_page_state` без пропуска, и действовать строго по возвращённому состоянию.
- **FR-010**: При состоянии `card_found` воркер вызывает `parse_card`, выполняет UPSERT в `new.listings` с обновлением полей `title`, `description`, `characteristics`, `price`, `seller_name`, `seller_profile_url`, `published_at`, `location_*`, `views_total`, а также устанавливает `status=success`, `processed_at=NOW()`, очищает `failure_reason` и фиксирует единичную запись в логах.
- **FR-011**: При состоянии `removed_or_not_found` система фиксирует `status=unavailable`, очищает `failure_reason` и переходит к следующей задаче без смены прокси.
- **FR-012**: При состояниях `proxy_block_403` или `proxy_block_407` воркер помечает текущий прокси как заблокированный, добавляет строку вида `ISO8601_TAB proxy_host:port TAB reason` в файл `/Users/stepanorlov/Desktop/STARTED/onezamer_v2/data/blocked_proxies.txt`, закрывает страницу, берёт следующий прокси из кольца и возвращает задачу в очередь.
- **FR-013**: При состояниях `proxy_block_429` или `captcha_geetest` воркер запускает `resolve_captcha_flow`; при успехе повторно детектирует страницу, при неуспехе переключается на следующий прокси, возвращает задачу в очередь и явно оставляет предыдущий прокси активным (без пометки block).
- **FR-014**: Все необработанные исключения внутри воркера приводят к локальному перезапуску воркера с возвратом задачи в очередь и записью причины в краткий лог.
- **FR-015**: Журнальные записи ограничиваются ключевыми событиями (старт задачи, результат `detect_page_state`, блокировка/переключение прокси, исчерпание попыток, завершение задачи) и оформляются одной строкой формата `event=item_id action=... proxy=...` на событие.
- **FR-016**: Итоговая сводка по завершении работы содержит только суммарные счётчики `processed`, `unavailable`, `errors`, `blocked_proxies`, `retries_used`, выводимые из `runner.py` без отдельного модуля метрик.
- **FR-017**: При остановке процесса воркеры обязаны вернуть активную задачу в очередь (если результат не зафиксирован), закрыть страницу и браузер, пометить прокси свободным и инициировать вывод итоговой сводки с минимальными счётчиками.

### Worker Processing Flow

1. **Инициализация**
   - Загрузить конфигурацию из `config.py` (значения читаются из `.env`: шаблоны URL, `MAX_ATTEMPTS`, паузы перед повторами, времена ожидания).
   - Получить следующий незаблокированный прокси из кольцевого пула под lock доступа и создать для него браузер Playwright + единственную страницу.
   - Привязать воркер к глобальному пулу соединений `asyncpg` и зарегистрировать себя в очереди задач.

2. **Получение задачи**
   - Запросить эксклюзивную задачу под внутренним lock очереди; очередь помечает `item_id` состоянием `in_progress`.
   - Записать компактный лог `event=task_start item_id=... proxy=... attempt=N`.

3. **Навигация**
   - Выполнить `page.goto(URL)` и дождаться `domcontentloaded` (или таймаута из конфига).
   - Немедленно вызвать `detect_page_state` и работать только с его результатом.

4. **Обработка состояний `detect_page_state`**
   - `card_found`: выполнить UPSERT (см. FR-010), проставить `status=success`, `processed_at`, очистить `failure_reason`, лог `event=task_success`.
   - `removed_or_not_found`: обновить запись `status=unavailable`, зафиксировать `failure_reason='removed_or_not_found'`, лог `event=task_missing`.
   - `catalog_page` или `seller_profile`: лог `event=unexpected_state`, вернуть задачу в очередь с увеличением попытки; при повторении >1 раза подряд принудительно сменить прокси, но не блокировать его.
   - `proxy_block_403` / `proxy_block_407`: записать строку `ISO8601	proxy	reason` в `blocked_proxies.txt`, закрыть страницу и браузер, пометить прокси заблокированным под lock пула, вернуть задачу в очередь, взять следующий прокси, перейти к шагу 1.
   - `proxy_block_429` / `captcha_geetest`: запустить `resolve_captcha_flow`; при успехе повторить детект, при неуспехе записать лог `event=captcha_failed`, сменить прокси под lock пула без блокировки предыдущего, вернуть задачу в очередь.
   - `DetectionError` или иное состояние: лог `event=detection_error`, вернуть задачу; при двух подряд повторениях сменить прокси.

5. **Ретраи и пределы**
   - Каждая возвратная задача увеличивает `attempt`.
   - При достижении `MAX_ATTEMPTS` воркер фиксирует в БД `status=error`, `failure_reason='attempt_limit'`, лог `event=task_failed`, задача не ставится в повторную очередь.

6. **Исключения и рестарт**
   - Любое непойманное исключение (ошибка Playwright/asyncpg) оформляется логом `event=worker_error`, активная задача возвращается в очередь с увеличением попытки, страница/браузер закрываются, воркер повторяет шаг 1 на новом прокси (или том же, если ошибка не сетевого характера).

7. **Завершение и отчётность**
   - По сигналу остановки воркер завершает текущую задачу по правилам (успешно или возвращает в очередь), закрывает страницу и браузер, освобождает прокси.
   - `runner.py` выводит одну строку `runner_finished processed=X unavailable=Y errors=Z blocked_proxies=W retries_used=R duration=...`.

### Key Entities *(include if feature involves data)*

- **ListingRecord**: Представляет объявление Avito; основные атрибуты — `item_id`, данные карточки, `status`, `failure_reason`, `processed_at`, `created_at`, `updated_at` в схеме `new`.
- **ProcessingTask**: Логическая задача на обработку одного ID; содержит ссылку на канонический URL, текущее состояние, счётчик попыток, отметку о последнем прокси.
- **ProxyEndpoint**: Элемент кольцевого пула; хранит адрес прокси, статус (активен/заблокирован), статистику блокировок и момент последней попытки.
- **BlockedProxyRecord**: Строка в файле `blocked_proxies.txt`, фиксирующая адрес прокси, время блокировки и причину.
- **WorkerSession**: Асинхронный воркер с собственными ссылками на браузер, страницу и текущий прокси.

## Assumptions

- Соединение с PostgreSQL доступно по реквизитам: host `81.30.105.134`, port `5402`, database `avito_zamer`, user `admin`, password `root`; используется только схема `new`.
- Файл `data/items.txt` формируется оператором заранее и содержит не менее одного валидного ID.
- Файл прокси `/Users/stepanorlov/Desktop/STARTED/onezamer_v2/data/proxies.txt` поддерживается оператором; система не редактирует его содержимое.
- Список заблокированных прокси сохраняется в файл `/Users/stepanorlov/Desktop/STARTED/onezamer_v2/data/blocked_proxies.txt`; название файла может быть уточнено при необходимости.
- Для MVP достаточно одной структуры данных `new.listings`; дополнительные справочники не требуются.
- `.env` хранится в корне проекта и обновляется оператором перед запуском; при его отсутствии используются значения по умолчанию из `config.py`.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001 (главный)**: После ручного запуска на контрольном наборе ID оператор подтверждает, что система завершила обработку без сбоев и дополнительных доработок и заявляет, что «всё хорошо и всё готово».
- **SC-002 (поддерживающий)**: Не менее 95% валидных объявлений из файла объёмом до 5 000 ID достигают статуса `success` или `unavailable` без ручных вмешательств в течение 30 минут работы системы.
- **SC-003 (поддерживающий)**: При первом запуске на пустой схеме `new` таблица `new.listings` и триггер создаются автоматически, что подтверждается успешной обработкой контрольного набора ID.
- **SC-004 (поддерживающий)**: Журналы содержат не более одного сообщения на задачу и на событие смены прокси, а минимальные метрики отображают суммарные значения без избыточных деталей.
- **SC-005 (поддерживающий)**: Файл `blocked_proxies.txt` пополняется не более чем одним уникальным прокси на блокировку, и операторы могут восстановить прокси, удалив его из файла без перезагрузки системы.
